/*
程序功能：快速排序
基本思路：
基本思路在于设定一个枢轴值，将序列小于、大于它的元素分别置于其两侧，再对2子序列重复该过程：
已知序列 arr[8]={49,38,65,97,76,13,27,49}，序列左右标记为 i,j；
默认选取最左边值 arr[low]为枢轴，先右边标记j左移，直到找到小于枢轴的元素 27；
将小元素 27 赋给 arr[i]，后左标记i右移，直到找到大于枢轴的元素 65；
将大元素 65 赋给 arr[j]，后右标记j左移，同理过程；
最终i，j相遇，该序列循环结束，本位置即为枢轴最终位置，枢轴将序列分割为2个子序列；
再分别对2个子序列重复这种找枢轴，移动标记，分割序列的过程，最终实现排序。

时间复杂度：
最坏情况：原序列接近有序 O(N^2)
最好情况：原序列接近无序 O(NlogN)

空间复杂度：
快速排序是递归进行的，而递归需要栈的辅助，因此复杂度 O(logN)
*/
#include<iostream>
using namespace std;

void QuickSort(int arr[], int low, int high)
{
    int temp;       //枢轴
    int i = low,j = high;       //左右标记

    if(low<high)    //左右标记未相遇，可再进行排序时
    {
        temp = arr[low];    //取得枢轴

        while(i<j)
        {
            while(j>i && arr[j]>=temp)  //先右标左移，直到小于枢轴的数
                --j;
            if(i<j)
            {
                arr[i] = arr[j];    //小元素前赋值
                ++i;
                /*
                注意此处 ++i(及后面的--j)：
                当前 arr[i] 被赋值元素已为合法元素(小于枢轴)，
				即无需在下面 while()++i 进行一次无意义的循环，省去一次判断(是否有实质性影响？)
				*/
            }

            while(i<j && arr[i]<temp)   //再左标右移，直到大于枢轴的数
                ++i;
            if(i<j)
            {
                arr[j] = arr[i];    //大元素后赋值
                --j;
            }
        }
        /*
		最终左右标记相遇，说明序列分割由枢轴分割未两个子序列：
		左序列均小于枢轴，右序列均大于枢轴；
		而且，枢轴所在位置即为最终有序的位置。
		*/
        arr[i] = temp;      //枢轴归位
        QuickSort(arr,low,i-1);     //排左序列
        QuickSort(arr,i+1,high);    //排右序列
    }
}

int main()
{
    int R[8] = {49,38,65,97,76,13,27,49};
    for(int i=0;i<8;i++)
        cout<<R[i]<<" ";
    cout<<endl;

    QuickSort(R,0,7);
    for(int i=0;i<8;i++)
        cout<<R[i]<<" ";
    return 0;
}

